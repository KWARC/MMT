package info.kwarc.mmt.latex

import info.kwarc.mmt.api._
import utils._
import frontend._
import symbols._
import modules._
import documents._
import objects._
import parser._
import presentation._
import notations._
import frontend.actions._


/** helper functions */
object MMTTeX {
  /** represents the special constant names generated by mmttex.sty counterpart when representing anonymous objects as defined constants */
  case class ObjectID(l1: Int, l2: Int, index: Int) {
    def toName = s"${ObjectID.prefix}$l1.$l2.$index"
    def toLatex = "\\csname " + toName + "\\endcsname"
  }
  object ObjectID {
    val prefix = "mmt@"
    def unapply(s: String): Option[ObjectID] = {
       if (s.startsWith(prefix)) {
         val parts = stringToList(s.substring(prefix.length), "\\.")
         parts match {
           case List(NumericString(l1),NumericString(l2),NumericString(ind)) =>
              Some(ObjectID(l1,l2,ind))
           case _ => None
         }
       } else
          None
    }
  }
}

import MMTTeX._

/**
 * to be used in conjunction with mmttex.sty
 * 
 * converts job.tex.mmt, which is generated by mmttex.sty when running latex,
 * into job.tex.mmt.sty, which is included by mmttex.sty when running latex a second time 
 */
class MMTTeX extends ShellExtension("mmttex") {
   def helpText: String = ""

   private val presenter = new MacroGeneratingPresenter
   
   override def start(args: List[String]) {
     initOther(presenter)
   }
   
   /**
    * expects path to job.tex as the command line argument
    */
   def run(shell: Shell, args: List[String]) = {
     val tex = File(args(0))
     val base = DPath(FileURI(tex))
     val mmt = tex.addExtension("mmt")
     val sty = mmt.addExtension("sty")
     val eh = new ErrorLogger(report)
     controller.getMathHub.foreach {mh => controller.backend.openArchive(mh.local)}
     val ps = ParsingStream.fromFile(mmt, dpathOpt = Some(base), formatOpt = Some("mmt"))
     log(mmt.toString + " -> " + sty.toString)
     controller.delete(base)
     val doc = controller.read(ps, true)(eh)
     //log(doc.toString)
     val writer = new StyWriter(sty, eh)
     writer.doDocument(doc)
     writer.jobFile.done
     true
   }

   /** scope that holds all global arguments needed while writing the sty file
    *  created once per file
    */
   private class StyWriter(sty: File, eh: ErrorHandler) {
     val jobFile = new FileWriter(sty)

     def doDocument(doc: Document) {
       doc.getModulesResolved(controller.globalLookup) foreach doModule
     }

     private def doModule(m: Module) {
        controller.simplifier(m)
        m match {
          case dt: DeclaredTheory => dt.meta.foreach {mt =>
            presenter(PlainInclude(mt, m.path))(jobFile)
          }
          case _ =>
        }
        m.getDeclarations.foreach {
          case c: Constant =>
             val name = c.name.toPath
             name match {
               case ObjectID(id) =>
                 c.df match {
                   case Some(df) =>
                     val dfL = presenter.asString(df, Some(c.path $ DefComponent))
                     jobFile << s"\\expandafter\\def${id.toLatex}{$dfL}\n"
                   case None => // malformed mmt file: generate error/warning
                 }
               case _ =>
                 presenter(c)(jobFile)
             }
          case nm: NestedModule =>
             doModule(nm.module)
          case i @ Include(_,_,_) =>
             presenter(i)(jobFile)
            // generate \RequirePackage for every include
            // we skip includes etc for now
        }
     }
   }
}
