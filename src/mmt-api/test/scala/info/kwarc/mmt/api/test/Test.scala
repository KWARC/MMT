package scala.info.kwarc.mmt.api.test

import info.kwarc.mmt.api
import info.kwarc.mmt.api.archives._
import info.kwarc.mmt.api._
import info.kwarc.mmt.doc.Setup
import info.kwarc.mmt.api.backend.MathHub
import info.kwarc.mmt.api.documents.Document
import info.kwarc.mmt.api.frontend.{Controller, Run}
import info.kwarc.mmt.api.objects.WFJudgement
import info.kwarc.mmt.api.parser.{ParsingStream, SourceRef}
import info.kwarc.mmt.api.utils.{File, FilePath, URI}
import org.scalatest.{FlatSpec, Matchers}

abstract class MMTTest(archives : String*)(extensions : String*) extends FlatSpec with Matchers /* with BeforeAndAfterAll */ {
  lazy val controller = Run.controller
  controller.extman.get(classOf[BuildQueue]).foreach(controller.extman.removeExtension)
  // controller.extman.getOrAddExtension(classOf[TrivialBuildManager])
  val standardextensions =
    List(
      "info.kwarc.mmt.api.ontology.AlignmentsServer",
      "info.kwarc.mmt.api.web.JSONBasedGraphServer"
  )
  val setupFolder = File("test/resources").canonical
  val content = setupFolder / "content"
  lazy val mathhub = new MathHub(MathHub.defaultURL,content,report = controller.report,https=true)

  behavior of "MMT"

  val setup = new Setup
  controller.extman.addExtension(setup)
  setup.setup(setupFolder/"system", content, None)
  (archives.toList) foreach (a =>
      if (!(content / a).toJava.exists()) it should "git clone " + a in mathhub.clone(a)
      else it should "git pull " + a in mathhub.pull(a)
  )

  (standardextensions ::: extensions.toList) foreach (e =>
    it should "add Extension " + e in hl("extension " + e)
    )

  val ret = it should "add archives" in {
    hl("mathpath archive " + content.toJava.getAbsolutePath)
    hl("log console")
  }

  // override protected def afterAll(): Unit = content.deleteDir


  def hl(s : String) = controller.handleLine(s)
  def shouldhl(s : String) = it should s in hl(s)

  def checkFile(archiveID : String, filename : String) = {
    val archive = controller.backend.getArchive(archiveID).getOrElse(throw TestError("Archive does not exist: " + archiveID))
    // val file = controller.backend.getArchive(archive).getOrElse(return List((archive,false)))/RedirectableDimension("source")/filename
    val errorCont = new TestErrorForwarder(controller)
    errorCont.reset
    try {
      val nsMap = controller.getNamespaceMap
      val ps = ParsingStream.fromSourceFile(archive,FilePath(filename))
      // read the document in a task that can be cancelled by the stop method
      val doc = controller.read(ps, true, true)(errorCont) match {
        case d: Document => d
        case _ => throw TestError("document expected")
      }
      val ret = errorCont.getAll
      ret.foreach(p => println("Error in " + p._1 + ": " + p._2.shortMsg))
      ret
    } catch {case e: Exception =>
      val msg = e.getClass + ": " + e.getMessage
      throw TestError("unknown error: " + msg).setCausedBy(e)
    }
  }

  def check(archiveID : String, files : String*) = {
    val archive = controller.backend.getArchive(archiveID).getOrElse(throw TestError("Archive does not exist: " + archiveID))
    val src = archive.root / archive.resolveDimension(RedirectableDimension("source")).toString
    var ret : List[(Path,api.Error)] = files.flatMap(f => checkFile(archiveID,f)).toList
    archive.traverse(RedirectableDimension("source"), FilePath(""), TraverseMode(f => File(f).getExtension.contains("mmt"), _ => true, false)){
      case Current(inFile, _) =>
        ret = ret ::: checkFile(archiveID,src.relativize(inFile).toString)
    }
    ret
  }

  def shouldcheck(archiveID : String, files : String*)(mayfail : List[String] = Nil, mustfail : List[String] = Nil) = it should "build " + archiveID + " without errors" in {
    var ret = check(archiveID,files:_*)
    val didntfail = mustfail.filterNot(c => ret.exists(p => p._1.toString == c))
    if (didntfail.nonEmpty) {
      println("Did not fail: " + didntfail.mkString(", "))
      ???
    }
    ret = ret.filterNot(p => mayfail contains p._1.toString)
    if (ret.nonEmpty) {
      println("There were errors!")
      ???
    }
  }
}

case class TestError(s : String) extends api.Error(s)

class TestErrorForwarder(controller: Controller) extends ErrorHandler {
  /**
    * remove all errors whose mainFile is src
    */
  private var errors : List[(Path,api.Error)] = Nil
  override def reset {
    errors = Nil
    super.reset
  }
  def getAll = {
    val ret = errors
    reset
    ret
  }
  override protected def addError(e: api.Error) : Unit = e match {
    case s: SourceError =>
      //generated by parsers
      val level = if (s.level == Level.Warning) 0 else 1
      val reg = s.ref.region
      val pos = reg.start
      // We permit the case that errors are found in other files than the current one. So we compute the file path
      val file = controller.backend.resolveLogical(s.ref.container) match {
        case Some((a, p)) => (a / archives.source / p).toString
        case None => s.ref.container match {
          case utils.FileURI(f) => f.toString
          case u => u.toString
        }
      }
      errors ::= (DPath(URI(file)),s)
    case e: Invalid =>
      //generated by checkers
      var mainMessage = e.shortMsg
      var extraMessages : List[String] = Nil
      val causeOpt: Option[Path] = e match {
        case e: InvalidObject => None
        case e: InvalidElement => Some(e.elem.path)
        case e: InvalidUnit => e.unit.component
      }
      causeOpt foreach (p => errors ::= (p,e))
  }
}


class APITest extends MMTTest()() {
  behavior of "APITest"
  lazy val brackets = (DPath(URI.http colon "cds.omdoc.org") / "mmt") ? "mmt" ? "brackets"
  it should "get a Constant: " in controller.getConstant(brackets)
}
