package info.kwarc.mmt.api.archives

import java.util.concurrent.ConcurrentLinkedQueue
import scala.collection.mutable.{HashMap}

import info.kwarc.mmt.api._
import frontend._
import utils._

/** */
class QueuedTask(val target: TraversingBuildTarget, val task: BuildTask) {
  /** task should be queued at end */
  var lowPriority: Boolean = true
  def highPriority = !lowPriority
  /** task was not requested directly but added as dependency of some other task */
  var dependencyClosure: Boolean = false

  var missingDeps: Iterable[Dependency] = Nil
}

/** */
sealed abstract class BuildResult {
   /** MMT modules that have been built successfully */
   val provided: List[MPath]
}

object BuildResult {
  def empty: BuildResult = BuildSuccess(Nil)
}

/** successful build */
case class BuildSuccess(provided: List[MPath]) extends BuildResult

/** unrecoverable failure */
case class BuildFailure(provided: List[MPath]) extends BuildResult

/** recoverable failure: build should be retried after building a missing dependency */
case class MissingDependency(provided: List[MPath], missingDeps: List[Dependency]) extends BuildResult


/** dependency of a [[QueuedTask]] */
abstract class Dependency

/** dependency on another [[BuildTask]]
 *  @param inPath path to file (without inDim)
 */
case class BuildDependency(key: String, archive: Archive, inPath: FilePath) extends Dependency

/** like [[BuildDependency]] but for a directory
 *  @param inPath path to file (without inDim)
 */
case class DirBuildDependency(key: String, archive: Archive, inPath: FilePath, children: List[BuildTask]) extends Dependency

/** a dependency on an MMT module that must be provided by building some other [[BuildTask]]
  *
  * providing the dependency typically requires some catalog to determine the appropriate [[BuildTask]]
  */
case class LogicalDependency(mpath: MPath) extends Dependency

/** a dependency on an externally provided source file that cannot be built by MMT
  *
  * this cannot be discharged by MMT, but changes to the file can trigger rebuilding
  */
case class ForeignDependency(file: File) extends Dependency


/** handles build tasks generated by a [[TraversingBuildTarget]] */
abstract class BuildManager extends Extension {
  def addTask(qts: Iterable[QueuedTask])
}

/**
  * builds tasks immediately (no queueing, no dependeny management, no parallel processing)
  */
class TrivialBuildManager extends BuildManager {
  def addTask(qts: Iterable[QueuedTask]) = qts.foreach {qt =>
    qt.target.runBuildTask(qt.task)
  }
}

/**
 * queues build tasks for multi-threaded execution, includes dependency management
 */
class BuildQueue extends BuildManager {
  private var queue: ConcurrentLinkedQueue[QueuedTask] = new ConcurrentLinkedQueue()

  /** all tasks currently in the queue */
  val alreadyQueued = new HashMap[Dependency,QueuedTask]
  /** all tasks that were built (successfully or permanently-failing) since the last time the queue was empty */
  val alreadyBuilt = new HashMap[Dependency,BuildResult]
  // TODO not efficient
  def moduleWasBuilt(mp: MPath) = alreadyBuilt.values.exists {e => e.provided contains mp}

  private var continue: Boolean = true
  private var stopOnEmpty: Boolean = false

  val sleepTime: Int = 2000

  def addTask(qts: Iterable[QueuedTask]) {
    synchronized {
      qts.foreach {qt =>
        val qtDep = qt.task.asDependency
        if (alreadyBuilt isDefinedAt qtDep) {
          if (qt.dependencyClosure) {
            // dependency of previous job: skip
            return
          } else {
            // new job: build anew
            alreadyBuilt -= qtDep
          }
        }
        if (alreadyQueued isDefinedAt qtDep) {
          if (qt.lowPriority) {
            // low priority: no need to add, skip
            return
          } else {
            // high priority: queue again
            queue.remove(alreadyQueued(qtDep))
            alreadyQueued -= qtDep
          }
        }
        // add to front/end of queue depending on priority
        if (qt.lowPriority) {
          queue.add(qt) //TODO add at end instead of front
        } else {
          queue.add(qt)
        }
        alreadyQueued(qtDep) = qt
      }
    }
  }

  /**
   * recursively queues all dependencies of the next task; then returns the head of the queue
   */
  private def getNextTask: Option[QueuedTask] = synchronized {
     val qt = queue.peek
     if (qt == null)
        return None
     // queue all dependencies at beginning
     qt.missingDeps = qt.missingDeps.flatMap {
        case bd: BuildDependency =>
           buildDependency(bd)
           Nil
        case bd: DirBuildDependency =>
           // skip for now
           // TODO
           Nil
        case ld: LogicalDependency =>
           if (moduleWasBuilt(ld.mpath))
              Nil
           else
              List(ld)
        case fd: ForeignDependency =>
           // should not happen, cannot be used at this point
           Nil
     }
     if (!qt.missingDeps.isEmpty) {
        // logical dependency has not been built yet
        //TODO what to do now? move to end of queue?
     }
     // all dependencies are queued now
     if (queue.peek != qt) {
        // recursively process the now-queued dependency
        getNextTask
     } else {
        // remove qt from queue and return it
        queue.poll
        alreadyQueued -= qt.task.asDependency
        Some(qt)
     }
  }

  private def buildDependency(bd: BuildDependency) {
     val target = controller.extman.get(classOf[TraversingBuildTarget], bd.key).getOrElse {
        // TODO
        return
     }
     val qts = target.makeBuildTasks(bd.archive, bd.inPath, None).map {qt =>
        qt.lowPriority = false
        qt.dependencyClosure = true
       qt
     }
    addTask(qts)
  }

  override def start(args: List[String]) {
    buildThread.start
  }

  override def destroy {
    synchronized {
      continue = false
    }
  }

  def destroyWhenQueueEmpty {
    synchronized {
      stopOnEmpty = true
    }
  }

  val buildThread = new Thread {
    override def run {
      while (continue) {
        getNextTask match {
          case Some(qt) =>
            // TODO run this in a Future
            val res = qt.target.runBuildTask(qt.task)
            res match {
              case _:BuildSuccess | _: BuildFailure =>
                 // remember finished build
                 val qtDep = qt.task.asDependency
                 alreadyBuilt(qtDep) = res
              case MissingDependency(provided, missing) =>
                 // register missing dependencies and requeue
                 qt.missingDeps = missing
                 queue.add(qt)
            }
          case None =>
            alreadyBuilt.clear
            if (stopOnEmpty)
              continue = false
            else
              Thread.sleep(sleepTime)
        }
      }
    }
  }

}
