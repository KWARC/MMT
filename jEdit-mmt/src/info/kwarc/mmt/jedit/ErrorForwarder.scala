package info.kwarc.mmt.jedit

import errorlist._
import info.kwarc.mmt.api._
import info.kwarc.mmt.api.archives.source
import info.kwarc.mmt.api.frontend._
import info.kwarc.mmt.api.objects._
import info.kwarc.mmt.api.parser._
import info.kwarc.mmt.api.utils.MyList._
import info.kwarc.mmt.api.utils._

class MMTError(val mainFile: File, es: ErrorSource, el: Int, sf: String, sl: Int, sc: Int, ec: Int, msg: String)
   extends DefaultErrorSource.DefaultError(es, el, sf, sl, sc, ec, msg)

/**
 * sends MMT errors directly to jEdit ErrorList
 * @param file the source file, in which the errors are found
 */
class ErrorListForwarder(errorSource: DefaultErrorSource, controller: Controller, src: File) extends ErrorHandler {
   /**
    * remove all errors whose mainFile is src
    */
   def reset {
      // we can't remove individual errors from a DefaultErrorSource, so remove everything and readd appropriately
      val errors = errorSource.getAllErrors
      errorSource.clear
      errors.foreach {case e: MMTError =>
         if (e.mainFile != src)
            errorSource.addError(e)
      }
   }
   protected def addError(e: Error) = e match {
      case s: SourceError =>
         //generated by parsers
         val tp = if (s.level == Level.Warning) ErrorSource.WARNING else ErrorSource.ERROR
         val reg = s.ref.region
         val pos = reg.start
         // We permit the case that errors are found in other files than the current one. So we compute the file path
         val file = controller.backend.resolveLogical(s.ref.container) match {
            case Some((a, p)) => (a / source / p).toString
            case None => s.ref.container match {
               case utils.FileURI(f) => f.toString
               case u => u.toString
            }
         }
         val error = new MMTError(src, errorSource, tp, file, pos.line, pos.column, pos.column + reg.length, s.mainMessage)
         s.extraMessages foreach {m => error.addExtraMessage(m)}
         errorSource.addError(error)
      case e: Invalid =>
         //generated by checkers
         var mainMessage = e.shortMsg
         var extraMessages : List[String] = Nil
         val causeOpt: Option[metadata.HasMetaData] = e match {
            case e: InvalidObject => Some(e.obj)
            case e: InvalidElement => Some(e.elem)
            case e: InvalidUnit =>
               val steps = e.history.getSteps.reverse
               extraMessages = steps.map(_.present(o => controller.presenter.asString(o)))
               val declOpt = e.unit.component.map(p => controller.localLookup.get(p.parent))
               // WFJudgement must exist because we always start with it
               // find first WFJudegment whose region is within the failed checking unit
               // but maybe lastWFJ.wfo has lost its region through simplification?
               declOpt flatMap {decl =>
                  SourceRef.get(decl).flatMap {bigRef =>
                     steps.mapFind {
                        case j: WFJudgement =>
                           SourceRef.get(j.wfo) flatMap {smallRef =>
                              if (bigRef contains smallRef) {
                                 mainMessage += ": " + controller.presenter.asString(j.wfo)
                                 Some(j.wfo)
                              } else
                                 None
                           }
                        case _ => None
                     }
                  }.orElse(declOpt)
               }
         }
         val ref = causeOpt.flatMap {cause => SourceRef.get(cause)}.getOrElse {
            mainMessage = "error with unknown location: " + mainMessage
            SourceRef(utils.FileURI(src), SourceRegion(SourcePosition(0,0,0), SourcePosition(0,0,0)))
         }
         val reg = ref.region
         val error = new MMTError(src, errorSource, ErrorSource.ERROR, src.toString,
               reg.start.line, reg.start.column, reg.start.column + reg.length, mainMessage)
         extraMessages foreach {m => error.addExtraMessage(m)}
         errorSource.addError(error)
      case e: Error =>
         // other errors, should not happen
         val error = new MMTError(src,
             errorSource, ErrorSource.ERROR, src.toString, 0, 0, 1, "error with unknown location: " + e.getMessage
         )
         e.toStringLong.split("\\n").foreach {m => error.addExtraMessage(m)}
         errorSource.addError(error)
   }
}
